#include <iostream>
#include <algorithm>

using namespace std;

int d[302][3]; 
// d[i][j] : i번째 계단까지 왔을 때 j개의 계단을 연속해서 밟고 얻은 점수의 최댓값을 저장
// j는 1 또는 2가 될 수 있으며, 1은 한 계단을 밟고 온 경우, 2는 두 계단을 연속해서 밟고 온 경우
int n; // 계단의 개수
int a[302]; // 각 계단의 점수

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for(int i=1;i<=n;i++) {
        cin >> a[i]; // 계단에 점수 부여
    }

    if(n==1) { // 계단이 하나만 있는 경우, 그 계단의 점수가 최댓값
        cout << a[1];
        return 0;
    }
    
    d[1][1] = a[1]; // 첫 번째 계단은 한 계단만 밟고 갈 수 있으므로 d[1][1]은 a[1]
    d[1][2] = 0; // 첫 번째 계단을 밟고 두 번째 계단을 밟는 경우는 없으므로 d[1][2]는 0
    d[2][1] = a[2]; // 두 번째 계단은 한 계단만 밟고 올 수 있으므로 d[2][1]은 a[2]
    d[2][2] = a[1]+a[2]; // 두 번째 계단은 두 계단을 연속해서 밟고 올 수 있으므로 d[2][2]는 a[1] + a[2]

    for(int i=3;i<=n;i++) {
        d[i][1] = max(d[i-2][1], d[i-2][2]) + a[i]; // d[i][1]은 두 계단 전(i-2)에서 한 계단만 밟고 오거나 두 계단을 연속해서 밟고 온 경우 중 최대값에 현재 계단의 점수를 더한 값
        d[i][2] = d[i-1][1] + a[i]; // d[i][2]는 바로 전 계단(i-1)에서 한 계단만 밟고 온 경우에 현재 계단의 점수를 더한 값
    }
    cout << max(d[n][1], d[n][2]); // 마지막 계단(n)에서 한 계단만 밟고 왔을 때(d[n][1])와 두 계단을 연속해서 밟고 왔을 때(d[n][2]) 중 최대값을 출력
    

}